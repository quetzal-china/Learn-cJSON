# THINKING.MD

本文件按时间顺序记录在学习 cJSON 源码过程中产生的**认知转折点**，
目标是构建可复用的工程思考模型，而非整理知识或复述代码行为。

## 写入准则（缺一不可）

一条记录 **必须同时满足**：

1. **明确锚点**
   - 绑定到一个具体的函数 / 数据结构 / 设计决策
   - 或一个跨文件的工程机制（如 allocator、error 传播方式）

2. **认知修正**
   - 明确写出：我原先的理解是什么，为什么是错的或不完整

3. **设计取舍**
   - 说明该实现是在权衡什么（性能 / 安全 / API 简洁 / 可测试性等）

4. **工程迁移价值**
   - 至少一句：这一思路在其他项目中我可以如何复用或避免

## 明确禁止

- 仅描述“这个函数做了什么”
- 对 AI / 文档内容的转述或整理
- 与工程决策无关的语法、字段枚举

本文件是**私人认知档案**，允许主观判断与假设，但必须指向源码事实。

## 最终自检
❓如果我把这条记录删掉，三个月后的我再读 cJSON，
   会不会重新掉进同一个理解陷阱？

## 示例结构模板
### YYYY-MM-DD | 锚点（函数 / 数据结构 / 机制）

【背景触发】
我是在什么代码位置 / 调试过程中注意到这个问题的？

【最初直觉】
我一开始是如何理解这一设计的？

【事实与证据】
代码中有哪些具体实现细节支撑或否定了我的直觉？

【认知修正】
基于代码事实，我的理解发生了什么变化？

【设计取舍】
这个实现是在权衡什么？它优先保证了什么，又可能放弃了什么？

【可迁移的工程结论】
这一思路在其他项目中我可以如何复用或刻意避免？

【待验证问题】
目前还不确定、但值得以后回头验证的点。

## Thinking
### 2026-02-09 | internal_hooks（cJSON 的内存分配机制）

【背景触发】
在阅读 cJSON 的解析流程时，我注意到几乎所有内存分配都没有直接调用 malloc/free，
而是通过一个名为 global_hooks 的结构体统一完成，这让我对它存在的必要性产生了疑问。

【最初直觉】
我一开始认为 internal_hooks 只是为了让用户可以自定义 malloc/free，
属于一种“可选增强”，对核心解析逻辑并不是必须的。

【事实与证据】
- cJSON 内部通过 global_hooks 间接完成所有内存分配和释放
- internal_hooks 是一个全局结构体，而不是作为参数传递
- cJSON_InitHooks 是一次性设置，对整个库生效

【认知修正】
internal_hooks 的作用不只是“允许替换内存分配函数”，
而是**强制所有代码遵循同一套内存分配规则**。

这意味着：
- 解析代码本身不需要关心内存的具体来源
- 内存策略被集中管理，而不是散落在各个函数中

【设计取舍】
目前我能够确认的是：
- 通过使用全局 hooks，cJSON 避免了在大量函数中重复处理内存策略
- 这是在用“全局统一”换取“实现简单和调用方便”

至于这种做法在更复杂场景下可能带来的问题，
目前我的知识还不足以完全判断。

【可迁移的工程结论】
在 C 项目中，如果某种资源管理逻辑会被大量函数反复使用，
通过集中机制统一管理，可以显著降低代码复杂度。

这种方式是否合适，需要结合项目规模进一步判断。

【待验证问题】
- 在更大规模或更复杂的项目中，全局内存管理机制可能会带来哪些问题？

### 2026-02-10 | strtod 使用中的 unsigned char** 类型转换问题

【背景触发】
在阅读 cJSON.c 中 parse_number 的实现时，
我注意到代码为了调用 strtod，将 unsigned char** 强制转换为 char**，
这让我对这种类型转换的安全性产生了疑问。

【最初直觉】
我一开始认为 unsigned char** 和 char** 在类型兼容方面是安全的，
因为 char** 可以看作是 unsigned char** 的一种“通用形式”，
这种转换在实际使用中应该不会出问题。

【事实与证据】
- strtod 的函数原型要求传入 char** 作为 endptr 参数
  - 函数原型: 
   `double strtod(const char *nptr, char **endptr);`
- cJSON 内部解析使用的是 unsigned char* 来处理输入字符
- 在调用 strtod 前，代码对指针做了显式的强制类型转换
- strtod 的行为仅是移动指针位置，并不修改字符串内容
```c
/* Convert a string to a floating-point number.  */
extern double strtod (const char *__restrict __nptr,
		      char **__restrict __endptr)
     __THROW __nonnull ((1));
```

【认知修正】
我意识到，这里的类型转换并不是“类型系统保证安全”，
而是**基于对 strtod 行为的假设**：

只要 strtod 不通过 endptr 修改指向的数据内容，
而只是写入“指针的位置”，
那么这种转换在当前使用场景下是可接受的。

也就是说，这是一种**依赖约定而非类型安全的做法**。

【设计取舍】
为了复用标准库的 strtod，
cJSON 选择接受一次不完全类型安全的转换，
以避免：
- 重新实现数字解析逻辑
- 引入额外的复杂代码

这是在用“对库行为的信任”换取实现上的简洁。

【可迁移的工程结论】
在 C 代码中：
- 某些类型转换在语义上是安全的，但类型系统无法表达
- 这种转换应尽量集中、显式出现，并伴随清晰的使用前提
- 如果对被调用函数的行为不确定，应避免此类做法

【待验证问题】
- C 标准是否对 strtod 使用 endptr 的行为有明确保证？
- 在不同实现的 libc 中，这种用法是否始终安全？

### 2026-02-11 | cJSON_SetValuestring 函数（引用节点的处理逻辑）

【背景触发】
在阅读 cJSON.c 文件的 cJSON_SetValuestring 函数（cJSON.c:548）时，
我注意到代码中有 `object->type & cJSON_IsReference` 的判断逻辑（cJSON.c:553），
这让我对"引用节点"的概念产生了疑问。

【最初直觉】
我原以为引用节点是类似于链表中next指针的作用，用于指向与它相关的地址或者其他cJSON节点。
对于C++的&引用，我知道是为了避免复制开销，但不确定两者的关系。

【事实与证据】
1. cJSON_IsReference 是一个值为 256 的宏（cJSON.h:76 `#define cJSON_IsReference 256`）
2. 引用节点的 type 字段包含 cJSON_String | cJSON_IsReference 标志
   （cJSON.c:2569 `item->type = cJSON_String | cJSON_IsReference;`）
3. 引用节点的 valuestring 直接指向外部传入的字符串
   （cJSON.c:2570 `item->valuestring = (char*)string;`）
4. cJSON_SetValuestring 函数会检查 object->type & cJSON_IsReference，
   如果是引用节点则返回 NULL（cJSON.c:553）
5. 在 cJSON_Delete 函数中，通过检查 `!(item->type & cJSON_IsReference)` 
   来决定是否释放 valuestring（cJSON.c:312）

【认知修正】
我意识到引用节点不是表示节点间的关系，而是节点本身的特性。
cJSON_IsReference 表示此节点包含的数据不只属于此节点，
不能采取简单的修改或内存释放操作（如 cJSON_SetValuestring 拒绝修改引用节点）。

【设计取舍】
1. 内存管理：cJSON_Delete 中通过标志位区分是否释放 valuestring，
   放弃了统一内存管理的简单性，换取了避免重复拷贝常量字符串的性能优势
   
2. API设计：cJSON_SetValuestring 对引用节点返回 NULL，
   放弃了API的一致性，换取了保护外部数据不被意外修改的安全性

3. 类型表示：cJSON 使用位运算（cJSON.h:89-101）而非 enum 来表示类型，
   例如 `cJSON_String | cJSON_IsReference` 组合多个标志
   - 放弃的：枚举类型的直观性和类型安全性
   - 换取的：运行时效率（位运算比枚举判断更快）和存储效率（多个标志存储在一个整数中）

【可迁移的工程结论】
- 当数据结构涉及到存储常量以及同时创建大量相同的不变的数据结构单元时，
  应该考虑引用机制，以避免重复拷贝开销
  
- 可以通过标志位区分不同所有权模式的数据，
  在运行时做出不同的处理决策（如是否释放内存）

【待验证问题】
- 引用节点指向的外部数据被提前释放会发生什么？
- 在哪些情况下，深拷贝是不可省略的，不推荐使用引用节点？