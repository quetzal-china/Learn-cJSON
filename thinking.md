# THINKING.MD

本文件按时间顺序记录在学习 cJSON 源码过程中产生的**认知转折点**，
目标是构建可复用的工程思考模型，而非整理知识或复述代码行为。

## 写入准则（缺一不可）

一条记录 **必须同时满足**：

1. **明确锚点**
   - 绑定到一个具体的函数 / 数据结构 / 设计决策
   - 或一个跨文件的工程机制（如 allocator、error 传播方式）

2. **认知修正**
   - 明确写出：我原先的理解是什么，为什么是错的或不完整

3. **设计取舍**
   - 说明该实现是在权衡什么（性能 / 安全 / API 简洁 / 可测试性等）

4. **工程迁移价值**
   - 至少一句：这一思路在其他项目中我可以如何复用或避免

## 明确禁止

- 仅描述“这个函数做了什么”
- 对 AI / 文档内容的转述或整理
- 与工程决策无关的语法、字段枚举

本文件是**私人认知档案**，允许主观判断与假设，但必须指向源码事实。

## 最终自检
❓如果我把这条记录删掉，三个月后的我再读 cJSON，
   会不会重新掉进同一个理解陷阱？

## 示例结构模板
### YYYY-MM-DD | 锚点（函数 / 数据结构 / 机制）

【背景触发】
我是在什么代码位置 / 调试过程中注意到这个问题的？

【最初直觉】
我一开始是如何理解这一设计的？

【事实与证据】
代码中有哪些具体实现细节支撑或否定了我的直觉？

【认知修正】
基于代码事实，我的理解发生了什么变化？

【设计取舍】
这个实现是在权衡什么？它优先保证了什么，又可能放弃了什么？

【可迁移的工程结论】
这一思路在其他项目中我可以如何复用或刻意避免？

【待验证问题】
目前还不确定、但值得以后回头验证的点。

## Thinking
### 2026-02-09 | internal_hooks（cJSON 的内存分配机制）

【背景触发】
在阅读 cJSON 的解析流程时，我注意到几乎所有内存分配都没有直接调用 malloc/free，
而是通过一个名为 global_hooks 的结构体统一完成，这让我对它存在的必要性产生了疑问。

【最初直觉】
我一开始认为 internal_hooks 只是为了让用户可以自定义 malloc/free，
属于一种“可选增强”，对核心解析逻辑并不是必须的。

【事实与证据】
- cJSON 内部通过 global_hooks 间接完成所有内存分配和释放
- internal_hooks 是一个全局结构体，而不是作为参数传递
- cJSON_InitHooks 是一次性设置，对整个库生效

【认知修正】
internal_hooks 的作用不只是“允许替换内存分配函数”，
而是**强制所有代码遵循同一套内存分配规则**。

这意味着：
- 解析代码本身不需要关心内存的具体来源
- 内存策略被集中管理，而不是散落在各个函数中

【设计取舍】
目前我能够确认的是：
- 通过使用全局 hooks，cJSON 避免了在大量函数中重复处理内存策略
- 这是在用“全局统一”换取“实现简单和调用方便”

至于这种做法在更复杂场景下可能带来的问题，
目前我的知识还不足以完全判断。

【可迁移的工程结论】
在 C 项目中，如果某种资源管理逻辑会被大量函数反复使用，
通过集中机制统一管理，可以显著降低代码复杂度。

这种方式是否合适，需要结合项目规模进一步判断。

【待验证问题】
- 在更大规模或更复杂的项目中，全局内存管理机制可能会带来哪些问题？

